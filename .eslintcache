[{"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\index.tsx":"1","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\App.tsx":"2","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Navbar.tsx":"3","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\reportWebVitals.ts":"4","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Home.tsx":"5","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Navbar\\Dropdown.tsx":"6","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Sorting\\Sorting.tsx":"7","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Slider.tsx":"8","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\DropSelect.tsx":"9","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Searching\\Searching.tsx":"10","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\Constants.tsx":"11","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Testing\\TestingZone.tsx":"12","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Speed\\Speed.tsx":"13"},{"size":568,"mtime":1607476430725,"results":"14","hashOfConfig":"15"},{"size":1862,"mtime":1607892075572,"results":"16","hashOfConfig":"17"},{"size":1442,"mtime":1607835093127,"results":"18","hashOfConfig":"17"},{"size":440,"mtime":1607459351851,"results":"19","hashOfConfig":"17"},{"size":239,"mtime":1607461502992,"results":"20","hashOfConfig":"15"},{"size":2258,"mtime":1607892571791,"results":"21","hashOfConfig":"17"},{"size":14785,"mtime":1607894842709,"results":"22","hashOfConfig":"17"},{"size":1902,"mtime":1607835151083,"results":"23","hashOfConfig":"17"},{"size":1024,"mtime":1607829418878,"results":"24","hashOfConfig":"17"},{"size":3540,"mtime":1607910378310,"results":"25","hashOfConfig":"17"},{"size":1002,"mtime":1607891983513,"results":"26","hashOfConfig":"17"},{"size":1972,"mtime":1607887365367,"results":"27","hashOfConfig":"17"},{"size":731,"mtime":1607892273466,"results":"28","hashOfConfig":"17"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1paq6h4",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"e9kocq",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\index.tsx",[],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\App.tsx",[],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Navbar.tsx",[],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\reportWebVitals.ts",[],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Home.tsx",[],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Navbar\\Dropdown.tsx",[],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Sorting\\Sorting.tsx",["56","57","58"],"import React, { useEffect, useLayoutEffect, useRef } from 'react'\r\nimport {useLocation} from 'react-router-dom';\r\nimport Slider from '../Slider';\r\nimport DropSelect from '../DropSelect'\r\nimport * as Tone from 'tone'\r\n\r\nexport default function Sorting(props:any) {\r\n    const [elements, setElements] = React.useState<Array<number>>([])\r\n    const [coloredElements, setColoredElements] = React.useState<Array<number>>([])\r\n    // const [canvas, setCanvas] = React.useState<HTMLElement | null>(null)\r\n    const [nOfElem, setNOfElem] = React.useState<number>(100)\r\n    const [DELAY, setDELAY] = React.useState<number>(40);\r\n    const [loc, setLoc] = React.useState<number>(0);\r\n    const [commands, setCommands] = React.useState<Array<Array<number>>>([])\r\n    const [playing, setPlaying] = React.useState<boolean>(false)\r\n    const [osc, setOsc] = React.useState<Tone.Oscillator>();\r\n    let path = useLocation().pathname\r\n\r\n    const resetElements = () => {\r\n        let arr:Array<number>\r\n        arr = []\r\n        for(let i=0;i<nOfElem;i++) {\r\n            arr.push(Math.floor(Math.random() *nOfElem))\r\n        }\r\n        setElements(prev => arr.slice(0))\r\n        setLoc(prev => 0)\r\n        setPlaying(false)\r\n        setTimeout(() => {\r\n            setColoredElements(prev => [-1,-1])\r\n            setCommands(prev => [])\r\n        }, 100)\r\n    }\r\n\r\n    const skipHandler = () => {\r\n        setPlaying(false)\r\n        for(let i=loc; i<commands.length;i++) {\r\n            commandHandler(i)\r\n        }\r\n        setCommands(prev => [])\r\n        setTimeout(() => {\r\n            setColoredElements([-1,-1])\r\n        }, 100)\r\n    }\r\n\r\n    const algorithmHandler = () => {\r\n        if(playing) return\r\n        switch(path) {\r\n            case \"/Insertionsort\":\r\n                insertionSort();\r\n                break;\r\n            case \"/Bubblesort\":\r\n                bubbleSort();\r\n                break;\r\n            case \"/Quicksort\":\r\n                quickSort();\r\n                break;\r\n            case \"/Mergesort\":\r\n                mergeSort();\r\n                break;\r\n            case \"/Selectionsort\":\r\n                selectionSort();\r\n                break;\r\n            case \"/Cocktailsort\":\r\n                cocktailSort();\r\n                break;\r\n            default:\r\n                return\r\n        }\r\n        setPlaying(true)\r\n\r\n    }\r\n\r\n    let insertionSort = () => {\r\n        let arr = elements.slice(0);\r\n        let j = 0;\r\n        let hold;\r\n        for(let i=1; i<arr.length;i++) {\r\n            j = i-1\r\n            while(j>=0 && arr[j]>arr[j+1]) {\r\n                hold = arr[j]\r\n                arr[j] = arr[j+1]\r\n                arr[j+1] = hold\r\n                markColoredElems(j, j+1)\r\n                swapElems(j, j+1)\r\n                j--\r\n            }\r\n        }\r\n    }\r\n\r\n    useEffect(() => {\r\n        if(commands.length===0) return \r\n        setTimeout(() => {\r\n            commandHandler(loc)\r\n        }, DELAY);\r\n    }, [loc])\r\n\r\n    useEffect(() => {\r\n        setOsc(new Tone.Oscillator(440, \"sine\").toDestination())\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n        if(playing) {\r\n            stepLoc(1)\r\n            if(osc===undefined) return\r\n            osc.start()\r\n        } else {\r\n            console.log(osc)\r\n            if(osc===null || osc===undefined) return\r\n            console.log('here ia m')\r\n            osc.stop()\r\n        }\r\n    }, [playing])\r\n    \r\n    let freqs = [\r\n        'C4','D4','E4','F4','G4','A4','B4',\r\n        'C5','D5','E5','F5','G5','A5','B5',\r\n    ]\r\n\r\n    let commandHandler = (i:number) => {\r\n        if(i>=commands.length) {\r\n            setPlaying(false)\r\n            setColoredElements([-1,-1])\r\n            return\r\n        }\r\n        let [method, first, second] = commands[i]\r\n        if(method===0) {\r\n            setColoredElements(prevState => [first, second])\r\n        } else if(method===1) {\r\n            setElements(prevState => {\r\n                if(osc!==undefined) {\r\n                    osc.set({\r\n                        frequency: freqs[Math.abs(Math.floor((((prevState[first]-prevState[second])/prevState.length)*freqs.length)))],\r\n                    });\r\n                }\r\n                let hold = prevState[first]\r\n                prevState[first] = prevState[second]\r\n                prevState[second] = hold\r\n                return prevState\r\n            })\r\n        } else {\r\n            setElements(prevState => {\r\n                if(osc!==undefined) {\r\n                    osc.set({\r\n                        frequency: freqs[Math.abs(Math.floor(((second/prevState.length)*freqs.length)))],\r\n                    });\r\n                }\r\n                prevState[first] = second\r\n                return prevState\r\n            })\r\n        }\r\n        if(playing) stepLoc(1)\r\n    }\r\n\r\n    let bubbleSort = () => {\r\n        let hold;\r\n        let count = 0\r\n        let arr = elements.slice(0)\r\n        for(let i=arr.length-1;i>=1;i--) {\r\n            count = 0\r\n            for(let j=0;j<i;j++) {\r\n                count++\r\n                setCommands(oldState => [...oldState, [0,j,j+1]])\r\n                if(arr[j]>arr[j+1]) {\r\n                    hold = arr[j]\r\n                    arr[j] = arr[j+1]\r\n                    arr[j+1] = hold\r\n                    setCommands(oldstate => [...oldstate, [1,j,j+1]])\r\n                }\r\n            }\r\n            if(count===0) return\r\n        }\r\n    }\r\n\r\n    let quickSortPartition = (arr:Array<number>, start:number, end:number) => {\r\n        let hold;\r\n        let x = arr[end]\r\n        let i = start-1\r\n        for(let j=start; j<end; j++) {\r\n            markColoredElems(j, j+1)\r\n            if(arr[j] <= x) {\r\n                i++\r\n                hold = arr[i]\r\n                arr[i] = arr[j]\r\n                arr[j] = hold\r\n                swapElems(i,j)\r\n            }\r\n        }\r\n        hold = arr[i+1]\r\n        arr[i+1] = arr[end]\r\n        arr[end] = hold\r\n        swapElems(i+1,end)\r\n        return i+1\r\n    }\r\n\r\n    let quickSortRecurse = (elem:Array<number>, start = 0, end = elem.length-1) => {\r\n        if(end<=start) return \r\n        let pivot;\r\n        pivot = quickSortPartition(elem, start, end)\r\n        quickSortRecurse(elem, start, pivot-1)\r\n        quickSortRecurse(elem, pivot+1, end)\r\n        return \r\n    }\r\n\r\n    let quickSort = () => {\r\n        quickSortRecurse(elements.slice(0))\r\n    }\r\n\r\n    let insertElement = (i:number, j:number) => {\r\n        setCommands(oldState => [...oldState, [2, i, j]])\r\n    }\r\n\r\n    let merge = (arr:Array<number>, start:number, middle:number, end:number) => {\r\n        let left = []\r\n        let right = []\r\n        let i =0\r\n        let j =0\r\n        let hold;\r\n        for(let i=start;i<=middle;i++) {\r\n            left.push(arr[i])\r\n        }\r\n        for(let i=middle+1;i<=end;i++) {\r\n            right.push(arr[i])\r\n        }\r\n        while(left.length!==0 && right.length!==0) {\r\n            markColoredElems(start+i, middle+1+j)\r\n            if(left[0] < right[0]) {\r\n                hold = left.splice(0,1)[0]\r\n                arr[start+i+j] = hold\r\n                insertElement(start+i+j, hold)\r\n                i++\r\n            } else {\r\n                hold = right.splice(0,1)[0]\r\n                arr[start+i+j] = hold\r\n                insertElement(start+i+j, hold)\r\n                j++\r\n            }\r\n        }\r\n        while(left.length!==0) {\r\n            hold = left.splice(0,1)[0]\r\n            arr[start+i+j] = hold\r\n            insertElement(start+i+j, hold)\r\n            i++\r\n        }\r\n        while(right.length!==0) {\r\n            hold = right.splice(0,1)[0]\r\n            arr[start+i+j] = hold\r\n            insertElement(start+i+j, hold)\r\n            j++\r\n        }\r\n    }\r\n    \r\n    let mergeSortRecurse = (arr:Array<number>,start=0,end=elements.length-1) => {\r\n        if(start>=end) return \r\n        let middle = Math.floor((end+start)/2);\r\n        mergeSortRecurse(arr, start, middle)\r\n        mergeSortRecurse(arr, middle+1, end)\r\n        merge(arr,start, middle, end)\r\n    }\r\n\r\n    let mergeSort = () => {\r\n        mergeSortRecurse(elements.slice(0))\r\n    }\r\n\r\n    let markColoredElems = (i:number,j:number) => {\r\n        setCommands(oldState => [...oldState, [0, i, j]])\r\n    }\r\n\r\n    let swapElems = (i:number,j:number) => {\r\n        setCommands(oldState => [...oldState, [1, i, j]])\r\n    }\r\n\r\n    let selectionSort = () => {\r\n        let least;\r\n        let leastInd = 0;\r\n        let arr = elements.slice(0)\r\n        let hold;\r\n        for(let i=0; i<arr.length;i++) {\r\n            least = Infinity\r\n            for(let j=i;j<arr.length;j++) {\r\n                if(arr[j]<least) {\r\n                    least = arr[j]\r\n                    leastInd = j\r\n                }\r\n                markColoredElems(leastInd,j)\r\n\r\n            }\r\n            hold = arr[i]\r\n            arr[i] = arr[leastInd]\r\n            arr[leastInd] = hold\r\n            swapElems(i, leastInd)\r\n        }\r\n    }\r\n\r\n    let cocktailSort = () => {\r\n        let arr = elements.slice(0)\r\n        let hold;\r\n        let passes=0\r\n        let count=0\r\n        let i=0\r\n        let j=arr.length-1\r\n        while (i<=j) {\r\n            count = 0\r\n            if(passes%2===0) {\r\n                for(let k=i;k<j;k++) {\r\n                    markColoredElems(k, j)\r\n                    if(arr[k]>arr[k+1]) {\r\n                        count++\r\n                        hold = arr[k]\r\n                        arr[k] = arr[k+1]\r\n                        arr[k+1] = hold\r\n                        swapElems(k,k+1)\r\n                    }\r\n                }\r\n                if(count===0) return\r\n                j--\r\n            } else {\r\n                for(let k=j;k>i;k--) {\r\n                    markColoredElems(k,i)\r\n                    if(arr[k]<arr[k-1]) {\r\n                        count++\r\n                        hold = arr[k]\r\n                        arr[k] = arr[k-1]\r\n                        arr[k-1] = hold\r\n                        swapElems(k,k-1)\r\n                    }\r\n                }\r\n                if(count===0) return\r\n                i++\r\n            }\r\n            passes++\r\n        }\r\n    }\r\n\r\n    // let maxHeap = () => {\r\n    //     let arr = elements\r\n    //     let hold;\r\n    //     let j\r\n    //     for(let i=1; i<arr.length; i++) {\r\n    //         j=i\r\n    //         while(j!==0) {\r\n    //             console.log('comparing', j, Math.floor(j/2))\r\n    //             if(arr[j]>arr[Math.floor(j/2)]) {\r\n    //                 hold = arr[j]\r\n    //                 arr[j] = arr[Math.floor(j/2)]\r\n    //                 arr[Math.floor(j/2)] = hold\r\n    //                 console.log(arr)\r\n    //             }\r\n    //             j = Math.floor(j/2)\r\n    //         }\r\n    //     }\r\n    //     setElements(arr.slice(0))\r\n    // }\r\n\r\n    // let heapify = (i=0) => {\r\n    //     let a = elements\r\n    //     let n = a.length-1\r\n    //     let left = 2*i;              //Left child index\r\n    //     let right = 2*i+1;           //Right child index\r\n    //     let maximum;\r\n    //     let hold;\r\n    //     if(i===0) {\r\n    //         left = 1\r\n    //         right = 2\r\n    //     }\r\n    //     if(right<n){                 //Checks if right child exist\r\n    //         if(a[left]>=a[right]){    //Compares children to find maximum\r\n    //             maximum = left;\r\n    //         }\r\n    //         else{\r\n    //             maximum = right;\r\n    //         }\r\n    //     }\r\n    //     else if(left<n){                //Checks if left child exists\r\n    //         maximum = left;\r\n    //     }\r\n    //     else return;                    //In case of no children return\r\n    //     if(a[i]<a[maximum]){            //Checks if the largest child is greater than parent\r\n    //         hold = a[i]\r\n    //         a[i] = a[maximum]\r\n    //         a[maximum] = hold          //If it is then swap both\r\n    //         setElements(a.slice(0))\r\n    //         heapify(maximum);       //max-heapify again\r\n    //     }\r\n    //     return;\r\n    // }\r\n\r\n    // let heapSort = () => {\r\n    //     maxHeap()\r\n    //     heapify()\r\n    // }\r\n    \r\n    useEffect(()=> {\r\n        resetElements()\r\n    }, [path, nOfElem])\r\n\r\n    const stepLoc = (dir:number) => {\r\n        setLoc(prevLoc => prevLoc+dir)\r\n    }\r\n\r\n    let MAXDELAY = 40\r\n\r\n    let delayChange = (newVal:number) => {\r\n        setDELAY(Math.floor((newVal)*(MAXDELAY-1))+1)\r\n    }\r\n\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null)\r\n\r\n    useLayoutEffect(() => {\r\n        if(canvasRef===null) return \r\n        const canvas = canvasRef.current;\r\n        const context = canvas!.getContext(\"2d\")\r\n        if(context===null) return\r\n        if(canvas===null) return\r\n        context?.clearRect(0, 0, canvas.width, canvas.height);\r\n        for(let i=0;i<elements.length;i++) {\r\n            context.fillStyle = (coloredElements.includes(i) ? \"#FF0000\" : \"#6b7280\")\r\n            context?.fillRect((i/nOfElem)*canvas.width, canvas.height, -(1/elements.length)*canvas.width, -(elements[i]/elements.length)*(canvas.height));\r\n        }\r\n    })\r\n\r\n    \r\n\r\n    return (\r\n        <div className=\"flex-1 w-full bg-gray-200 items-center flex flex-col h-full py-12 \">\r\n            <div className=\"container flex flex-col bg-white shadow-md rounded\">\r\n                <div className=\"flex w-full justify-between items-center mb-6 p-5\">\r\n                    <h1 className=\"text-4xl font-medium text-left\">{props.title}</h1>\r\n                    <DropSelect label=\"Elements\" value={nOfElem} onChange={(event:number) => setNOfElem(event)}/>\r\n                    <div>\r\n                        <button onClick={() => playing ? setPlaying(false) : commands.length===0 ? algorithmHandler() : !playing ? setPlaying(true) : ''} className={\"bg-green-500 focus:outline-none mr-6 animation-fast text-white px-3 py-2 text-lg rounded \"}>{playing ? 'Pause' : 'Play'}</button>\r\n                        <button onClick={() => playing ? skipHandler() : ''} className={\"bg-green-500 focus:outline-none animation-fast text-white px-3 py-2 text-lg rounded \" + (!playing ? \"bg-opacity-25 cursor-none\" : \"hover:bg-green-600\")}>Skip</button>\r\n                    </div>\r\n                    <Slider className=\"mx-auto\" label=\"Speed\" value={loc} onChange={(event:number) => delayChange(event)}/>\r\n                    <button onClick={() => !playing ? resetElements() : ''} className={\"bg-gray-500 focus:outline-none animation-fast text-white px-3 py-2 text-lg rounded \"  + (!playing ? \"hover:bg-gray-600\" : \"bg-opacity-25 cursor-none\")}>Reset</button>\r\n                </div>\r\n                <div className=\"w-full flex-1 flex items-end rounded-md h-64 px-1\">\r\n                    <canvas className=\"mx-auto\" width=\"1240\" height=\"260\" ref={canvasRef} id=\"mycanvas\"></canvas>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Slider.tsx",[],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\DropSelect.tsx",[],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Searching\\Searching.tsx",["59","60","61","62","63","64"],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\Constants.tsx",[],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Testing\\TestingZone.tsx",["65"],"C:\\Users\\atd68\\Desktop\\DataStructuresReact\\src\\components\\Speed\\Speed.tsx",[],{"ruleId":"66","severity":1,"message":"67","line":95,"column":8,"nodeType":"68","endLine":95,"endColumn":13,"suggestions":"69"},{"ruleId":"66","severity":1,"message":"70","line":112,"column":8,"nodeType":"68","endLine":112,"endColumn":17,"suggestions":"71"},{"ruleId":"66","severity":1,"message":"72","line":394,"column":8,"nodeType":"68","endLine":394,"endColumn":23,"suggestions":"73"},{"ruleId":"74","severity":1,"message":"75","line":1,"column":24,"nodeType":"76","messageId":"77","endLine":1,"endColumn":39},{"ruleId":"74","severity":1,"message":"78","line":16,"column":11,"nodeType":"76","messageId":"77","endLine":16,"endColumn":19},{"ruleId":"74","severity":1,"message":"79","line":34,"column":13,"nodeType":"76","messageId":"77","endLine":34,"endColumn":31},{"ruleId":"66","severity":1,"message":"80","line":56,"column":8,"nodeType":"68","endLine":56,"endColumn":15,"suggestions":"81"},{"ruleId":"74","severity":1,"message":"82","line":58,"column":11,"nodeType":"76","messageId":"77","endLine":58,"endColumn":19},{"ruleId":"66","severity":1,"message":"83","line":62,"column":5,"nodeType":"76","endLine":62,"endColumn":14,"suggestions":"84"},{"ruleId":"74","severity":1,"message":"85","line":4,"column":12,"nodeType":"76","messageId":"77","endLine":4,"endColumn":15},"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'DELAY', 'commandHandler', and 'commands.length'. Either include them or remove the dependency array.","ArrayExpression",["86"],"React Hook useEffect has a missing dependency: 'osc'. Either include it or remove the dependency array.",["87"],"React Hook useEffect has a missing dependency: 'resetElements'. Either include it or remove the dependency array.",["88"],"@typescript-eslint/no-unused-vars","'useLayoutEffect' is defined but never used.","Identifier","unusedVar","'addEdges' is assigned a value but never used.","'prev' is defined but never used.","React Hook useEffect has missing dependencies: 'addNewPoint' and 'numElements'. Either include them or remove the dependency array.",["89"],"'getHypot' is assigned a value but never used.","React Hook useEffect contains a call to 'setCanvHeight'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [graph, numElements, addNewPoint] as a second argument to the useEffect Hook.",["90"],"'loc' is assigned a value but never used.",{"desc":"91","fix":"92"},{"desc":"93","fix":"94"},{"desc":"95","fix":"96"},{"desc":"97","fix":"98"},{"desc":"99","fix":"100"},"Update the dependencies array to be: [DELAY, commandHandler, commands.length, loc]",{"range":"101","text":"102"},"Update the dependencies array to be: [osc, playing]",{"range":"103","text":"104"},"Update the dependencies array to be: [path, nOfElem, resetElements]",{"range":"105","text":"106"},"Update the dependencies array to be: [addNewPoint, graph, numElements]",{"range":"107","text":"108"},"Add dependencies array: [graph, numElements, addNewPoint]",{"range":"109","text":"110"},[2955,2960],"[DELAY, commandHandler, commands.length, loc]",[3385,3394],"[osc, playing]",[12108,12123],"[path, nOfElem, resetElements]",[1849,1856],"[addNewPoint, graph, numElements]",[2897,2897],", [graph, numElements, addNewPoint]"]